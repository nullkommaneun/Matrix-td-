<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Closure Hub — Aufarbeitung</title>
<style>
  :root {
    --bg: #0a0d0a;
    --panel: #121515;
    --neon: #00ff88;
    --text: #b8f1d9;
    --muted: #7bc6a7;
    --danger: #ff4d4d;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    background: var(--bg);
    color: var(--text);
  }
  h1,h2,h3 { margin: 0.2rem 0 0.6rem; color: var(--neon); }
  .wrap { padding: 16px; max-width: 1400px; margin: 0 auto; }
  .hidden { display: none !important; }

  /* Retro Panel */
  .panel {
    border: 1px solid var(--neon);
    background: linear-gradient(135deg, rgba(18,21,21,0.95), rgba(18,21,21,0.9)),
                repeating-linear-gradient(45deg, rgba(255,255,255,0.03) 0 2px, rgba(0,0,0,0.04) 2px 4px);
    padding: 12px;
    border-radius: 6px;
    position: relative;
  }
  .panel:before, .panel:after {
    content: "";
    position: absolute;
    width: 6px; height: 6px;
    background: var(--bg);
    border: 1px solid var(--neon);
    border-radius: 50%;
  }
  .panel:before { top: -4px; left: -4px; }
  .panel:after  { bottom: -4px; right: -4px; }

  /* Layout */
  .row { display: grid; gap: 12px; }
  .row.cols-2 { grid-template-columns: 1fr 1fr; }
  .row.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  .header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 8px;
  }

  /* Inputs/Buttons */
  button, input, select {
    font: inherit; color: var(--text); background: var(--panel); border: 1px solid var(--neon);
    border-radius: 4px; padding: 6px 10px;
  }
  button { cursor: pointer; }
  button.primary { background: var(--neon); color: #000; border-color: var(--neon); }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .inline { display: inline-flex; align-items: center; gap: 8px; }
  .muted { color: var(--muted); }
  .danger { color: var(--danger); }
  .pill { border: 1px solid var(--neon); padding: 2px 6px; border-radius: 999px; font-size: 12px; color: var(--muted); }
  .stat-row { display: grid; grid-template-columns: 180px 36px 50px 36px; gap: 8px; align-items: center; margin: 6px 0; }

  .log {
    height: 60vh; overflow: auto; padding-right: 6px; font-size: 13px; line-height: 1.25rem;
    scrollbar-color: var(--neon) transparent;
  }
  .option-card { border: 1px solid var(--neon); border-radius: 6px; padding: 10px; margin: 8px 0; }
  .badge { display:inline-block; font-size:11px; padding:2px 6px; border:1px solid var(--neon); border-radius:999px; margin-left:6px; color:var(--muted); }
  .meta { font-size:12px; color:var(--muted); }

  /* --- Fokusmodus (kompakt) --- */
  body.focus .option-card .details { display: none; }
  body.focus .option-card { padding: 8px; }
  body.focus .option-card h4 { margin: 0 0 4px; }
  .toggle { font-size:12px; text-decoration:underline; cursor:pointer; border:0; background:none; color:var(--muted); padding:0; }
  .sep { height: 1px; background: linear-gradient(90deg, transparent, var(--neon), transparent); margin: 8px 0; opacity: .4;}
</style>
</head>
<body>
<div class="wrap">

  <!-- START SCREEN -->
  <section id="start-screen">
    <h1>Closure Hub — Aufarbeitung</h1>
    <div class="row cols-2">
      <div class="panel">
        <h3>Profil (anonym)</h3>
        <div class="inline" style="gap:12px; flex-wrap: wrap;">
          <div><span class="muted">Kontext:</span> <span class="pill">Beziehungs-Aufarbeitung</span></div>
          <div><span class="muted">Modus:</span> <span class="pill">Selbstreflexion</span></div>
        </div>
        <div class="sep"></div>
        <div class="inline" style="gap:10px; flex-wrap:wrap;">
          <div class="inline">
            <span class="muted">Geschlecht:</span> <span id="gender-label">Divers</span>
            <button id="gender-toggle">Toggle</button>
          </div>
          <div class="inline">
            <span class="muted">Alter:</span>
            <button id="age-minus">−</button>
            <span id="age-val" style="display:inline-block; width:48px; text-align:center;">18</span>
            <button id="age-plus">+</button>
          </div>
          <div class="inline">
            <span class="muted">Seed (optional):</span>
            <input id="seed-input" placeholder="z. B. 12345" style="min-width:180px;" />
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>Attribute – Punkte übrig: <span id="pts-left">10</span></h3>
        <div class="stat-row">
          <div>Selbstbild <span class="muted">(Appearance)</span></div>
          <button data-stat="Appearance" data-delta="-1">−</button>
          <div id="stat-Appearance" style="text-align:center;">2</div>
          <button data-stat="Appearance" data-delta="1">+</button>
        </div>
        <div class="stat-row">
          <div>Körper/Ruhe <span class="muted">(Physique)</span></div>
          <button data-stat="Physique" data-delta="-1">−</button>
          <div id="stat-Physique" style="text-align:center;">2</div>
          <button data-stat="Physique" data-delta="1">+</button>
        </div>
        <div class="stat-row">
          <div>Klarheit <span class="muted">(Intellect)</span></div>
          <button data-stat="Intellect" data-delta="-1">−</button>
          <div id="stat-Intellect" style="text-align:center;">2</div>
          <button data-stat="Intellect" data-delta="1">+</button>
        </div>
        <div class="stat-row">
          <div>Glück <span class="muted">(Luck)</span></div>
          <button data-stat="Luck" data-delta="-1">−</button>
          <div id="stat-Luck" style="text-align:center;">2</div>
          <button data-stat="Luck" data-delta="1">+</button>
        </div>
      </div>
    </div>

    <div style="margin-top:10px;">
      <button id="confirm-btn" class="primary" disabled>Start</button>
      <span class="muted">Verteile alle Punkte, um zu starten.</span>
    </div>

    <p class="muted" style="margin-top:10px; font-size:12px;">
      Hinweis: Dieses Spiel ist **Selbstreflexion**, keine Therapie. Inhalte sind anonym & allgemein.
    </p>
  </section>

  <!-- GAME SCREEN -->
  <section id="game-screen" class="hidden">
    <div class="header">
      <h2>Closure Hub</h2>
      <div class="inline">
        <button id="btn-focus">Fokusmodus: AUS</button>
        <button id="btn-refresh">Optionen aktualisieren</button>
        <button id="btn-exit">Freiwillig beenden</button>
        <button id="btn-restart">Neustart</button>
      </div>
    </div>

    <div class="row cols-3">
      <div class="panel">
        <h3>Optionen <span class="muted">(safe / medium / hard)</span></h3>
        <div id="options"></div>
      </div>

      <div class="panel">
        <h3>Ereignis-Log</h3>
        <div class="log" id="log"></div>
      </div>

      <div class="panel">
        <h3>Status & Fortschritt</h3>
        <div id="status"></div>
        <div class="sep"></div>
        <h3>Cooldowns</h3>
        <div id="cooldowns"></div>
      </div>
    </div>
  </section>

  <!-- END SCREEN -->
  <section id="end-screen" class="hidden">
    <div class="panel" style="max-width:800px; margin: 20vh auto 0;">
      <h2 id="end-title">Ende</h2>
      <p id="end-summary" class="muted"></p>
      <div style="margin-top:12px;">
        <button id="btn-to-start" class="primary">Zurück zum Start</button>
      </div>
    </div>
  </section>
</div>

<script>
/* ---------- Seeded RNG (xmur3 + sfc32) ---------- */
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i=0; i<str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353); h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}
function sfc32(a, b, c, d) {
  return function() {
    a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
    let t = (a + b) | 0;
    a = b ^ (b >>> 9);
    b = (c + (c << 3)) | 0;
    c = (c << 21) | (c >>> 11);
    d = (d + 1) | 0;
    t = (t + d) | 0;
    c = (c + t) | 0;
    return (t >>> 0) / 4294967296;
  }
}
function makeRngFromSeed(seedStr) {
  const seeder = xmur3(seedStr);
  return sfc32(seeder(), seeder(), seeder(), seeder());
}

/* ---------- Enums/Types ---------- */
const Stat = { Appearance:"Appearance", Physique:"Physique", Intellect:"Intellect", Luck:"Luck" };
const Perk = { Networker:"Networker", Workhorse:"Workhorse", Analytical:"Analytical", Stoic:"Stoic", Creative:"Creative", LuckyBreak:"LuckyBreak" };
const Path = { Ausbildung:"Ausbildung", Universitaet:"Universitaet", Freelancer:"Freelancer" }; // technisch beibehalten
const Risk = { Safe:"Safe", Medium:"Medium", Hard:"Hard" };
const BACKGROUNDS = ["Neutral"];

/* ---------- Helpers ---------- */
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const signStr = (n) => (n >= 0 ? "+"+n : ""+n);

function choiceByWeights(rng, weights) {
  const total = weights.reduce((a,b)=>a+b, 0);
  if (total <= 0) return -1;
  let t = rng() * total, cum = 0;
  for (let i=0;i<weights.length;i++){ cum += weights[i]; if (t <= cum) return i; }
  return weights.length - 1;
}
function d10(rng){ return 1 + Math.floor(rng()*10); }

function luckShift(luck, perks) {
  const shift = Math.min(2, Math.floor(luck/5));
  const lucky = (perks.has(Perk.LuckyBreak) && luck <= 8) ? 1 : 0;
  return shift + lucky;
}
function perkStatBonus(perks, def) {
  let bonus = 0;
  if (perks.has(Perk.Networker) && def.tags.includes("networking")) bonus += 2;
  if (perks.has(Perk.Analytical) && def.tags.includes("reflect")) bonus += 2; // logischere Zuordnung
  return bonus;
}
function applyPerkEconomy(perks, def, stressDelta, hopeDelta, xpGain) {
  // "hopeDelta" nutzt frühere money-Logik als Hoffnung (±)
  let s = stressDelta, h = hopeDelta, x = xpGain;
  if (perks.has(Perk.Workhorse) && def.tags.includes("stabilize")) { s = Math.trunc(s * 0.85); h = Math.trunc(h * 1.10); }
  if (perks.has(Perk.Stoic) && s > 0) s = Math.trunc(s * 0.90);
  if (perks.has(Perk.Creative) && def.tags.includes("growth")) x = Math.trunc(x * 1.10);
  return [s, h, x];
}
function successProbability(state, def, dc) {
  const baseStat = state.stats[def.stat];
  const statBonus = perkStatBonus(state.perks, def);
  const ls = luckShift(state.stats.Luck, state.perks);
  let successes = 0;
  for (let r=1;r<=10;r++){
    const total = baseStat + statBonus + r + ls;
    if (total >= dc) successes++;
  }
  return successes * 10; // in %
}

/* ---------- Content: Actions (Beziehungs-Aufarbeitung) ---------- */
function makeActions() {
  const list = [];
  const A = (o)=>({ cooldown:0, tags:[], pathRestriction:null, prereq:()=>true, onSuccess:()=>{}, onFailure:()=>{}, ...o });

  // Erholung
  list.push(A({ id:"breath_reset", name:"Atem-Reset", desc:"Beruhigt, erdet.", baseDC:0, stat:Stat.Physique,
    energyCost:-10, stressDelta:-20, moneyDelta:0, xpGain:0, tags:["rest","stabilize"] }));
  list.push(A({ id:"mindfulness_5", name:"5-Min Achtsamkeit", desc:"Auf Körper & Atem fokussieren.", baseDC:0, stat:Stat.Physique,
    energyCost:-5, stressDelta:-15, moneyDelta:0, xpGain:0, tags:["rest","stabilize"] }));

  // Kern-Aufarbeitung
  list.push(A({ id:"journal_patterns", name:"Journaling: Muster", desc:"3 wiederkehrende Konfliktmuster benennen.", baseDC:7, stat:Stat.Intellect,
    energyCost:12, stressDelta:8, moneyDelta:0, xpGain:12, tags:["reflect","milestone-setup"] }));

  list.push(A({ id:"values_list", name:"Werte-Inventur", desc:"Top-5 Werte & Grenzen notieren.", baseDC:8, stat:Stat.Intellect,
    energyCost:14, stressDelta:8, moneyDelta:0, xpGain:14, tags:["reflect","boundaries","milestone-setup"] }));

  list.push(A({ id:"digital_hygiene", name:"Digital: Mute/Archive", desc:"Benachrichtigungen stummschalten, Chat archivieren.", baseDC:7, stat:Stat.Appearance,
    energyCost:6, stressDelta:6, moneyDelta:0, xpGain:8, tags:["contact_mgmt","stabilize"] }));

  list.push(A({ id:"no_contact_action", name:"Kein-Kontakt-Schritt", desc:"1 konkreter Schritt ohne Kontakt.", baseDC:8, stat:Stat.Appearance,
    energyCost:10, stressDelta:10, moneyDelta:0, xpGain:12, tags:["contact_mgmt","milestone-setup"], cooldown:1 }));

  list.push(A({ id:"support_call", name:"Support-Gespräch", desc:"20 Min mit Vertrauensperson (sachlich).", baseDC:8, stat:Stat.Appearance,
    energyCost:8, stressDelta:8, moneyDelta:0, xpGain:10, tags:["network","stabilize"] }));

  list.push(A({ id:"trigger_map", name:"Trigger-Karte", desc:"Auslöser → Reaktion → Gegenzug skizzieren.", baseDC:9, stat:Stat.Intellect,
    energyCost:16, stressDelta:10, moneyDelta:0, xpGain:18, tags:["skills","milestone-setup"] }));

  list.push(A({ id:"boundary_script", name:"Grenzen-Script", desc:"Zwei Ich-Botschaften formulieren.", baseDC:8, stat:Stat.Appearance,
    energyCost:12, stressDelta:10, moneyDelta:0, xpGain:14, tags:["boundaries","skills"] }));

  list.push(A({ id:"memory_reframe", name:"Erinnerung reframen", desc:"Eine Szene neutral neu beschreiben.", baseDC:9, stat:Stat.Intellect,
    energyCost:14, stressDelta:10, moneyDelta:0, xpGain:16, tags:["reflect"] }));

  list.push(A({ id:"return_items", name:"Gegenstände klären", desc:"Eigene Dinge sichern / Rückgabe regeln (ohne Treffen).", baseDC:10, stat:Stat.Appearance,
    energyCost:16, stressDelta:14, moneyDelta:0, xpGain:16, tags:["contact_mgmt","closure"], prereq:(s)=> (s.successTags.get("contact_mgmt")||0) >= 2 }));

  list.push(A({ id:"routine_pillar", name:"Routine-Pfeiler", desc:"Tägliche Micro-Routine festlegen.", baseDC:7, stat:Stat.Physique,
    energyCost:10, stressDelta:6, moneyDelta:0, xpGain:10, tags:["stabilize","milestone-setup"], cooldown:1 }));

  list.push(A({ id:"redflags_sheet", name:"Red-Flags-Sheet", desc:"Eigene Warnsignale notieren.", baseDC:8, stat:Stat.Intellect,
    energyCost:12, stressDelta:10, moneyDelta:0, xpGain:12, tags:["reflect"] }));

  list.push(A({ id:"future_vision", name:"Zukunftsbild", desc:"3 Kriterien für gesunde Beziehung definieren.", baseDC:8, stat:Stat.Intellect,
    energyCost:12, stressDelta:8, moneyDelta:0, xpGain:12, tags:["growth","milestone-setup"] }));

  list.push(A({ id:"relapse_plan", name:"Rückfall-Plan", desc:"Wenn Kontaktimpuls X → Handlung Y.", baseDC:9, stat:Stat.Intellect,
    energyCost:14, stressDelta:10, moneyDelta:0, xpGain:16, tags:["skills","stabilize"] }));

  return list;
}

/* ---------- Milestones (Aufarbeitung) ---------- */
function makeMilestones() {
  return [
    { id:"clarity", name:"Klarheit gewonnen", desc:"Muster & Werte benannt.", path:Path.Ausbildung, isPinnacle:false,
      requirements:(s)=> (s.successTags.get("reflect")||0) >= 3,
      rewards:(s)=> s.xp += 20 },

    { id:"contact_solid", name:"Kontakt kompakt", desc:"Mehrere Kontakt-Management-Schritte.", path:Path.Ausbildung, isPinnacle:false,
      requirements:(s)=> (s.successTags.get("contact_mgmt")||0) >= 3,
      rewards:(s)=> s.perks.add(Perk.Stoic) },

    { id:"triggers_mastered", name:"Trigger-Kompetenz", desc:"Trigger-Karte + Grenzen-Script.", path:Path.Ausbildung, isPinnacle:false,
      requirements:(s)=> (s.successTags.get("skills")||0) >= 2,
      rewards:(s)=> s.money += 50 }, // symbolische "Hoffnung"
    
    { id:"new_pillars", name:"Neue Pfeiler", desc:"Routinen etabliert, Zukunftsbild skizziert.", path:Path.Ausbildung, isPinnacle:true,
      requirements:(s)=> (s.successTags.get("milestone-setup")||0) >= 4 && s.xp >= 80,
      rewards:(s)=> s.perks.add(Perk.Creative) },
  ];
}

/* ---------- Engine ---------- */
function createState(meta, stats, perks, path, seedStr) {
  const rng = makeRngFromSeed(seedStr);
  return {
    meta, stats, perks, path, rng,
    energy: 100, stress: 0, money: 0, xp: 0,            // money == Hoffnung (±)
    cooldowns: new Map(),
    sinceSeen: new Map(),
    successTags: new Map(),
    certificates: new Set(),
    history: [],
    milestonesAchieved: new Set(),
    ended: false, endTitle: "", endSummary: ""
  };
}
function pickOptions(state, pool) {
  const risks = [Risk.Safe, Risk.Medium, Risk.Hard];
  const targets = new Map([
    [Risk.Safe,   6 + Math.floor(state.rng()*2)], // 6..7
    [Risk.Medium, 8 + Math.floor(state.rng()*2)], // 8..9
    [Risk.Hard,  10 + Math.floor(state.rng()*2)]  // 10..11
  ]);
  const out = [];
  const X_NEU = 5;

  pool.forEach(def=>{
    state.sinceSeen.set(def.id, (state.sinceSeen.get(def.id) ?? (X_NEU+1)) + 1);
  });

  for (const risk of risks) {
    const target = targets.get(risk);
    const candidates = pool.filter(def=>{
      const cd = state.cooldowns.get(def.id) ?? 0;
      const pathOK = (def.pathRestriction === null) || (def.pathRestriction === state.path);
      return pathOK && def.prereq(state) && cd <= 0;
    });
    if (candidates.length === 0) continue;

    const weights = candidates.map(def=>{
      const fitGrad = 1 - (Math.abs(def.baseDC - target)/5);
      let w = Math.max(0, Math.min(1, fitGrad));
      if (state.stress >= 70 && def.tags.includes("rest")) w *= 1.5;
      if (state.energy <= 30 && def.energyCost >= 25) w *= 0.6;
      if (def.tags.includes("milestone-setup")) w *= 1.25;
      const age = state.sinceSeen.get(def.id) ?? (X_NEU+1);
      w *= (age > X_NEU) ? 1.2 : 0.8;
      return w;
    });
    let idx = choiceByWeights(state.rng, weights);
    if (idx >= 0) {
      const chosen = candidates[idx];
      state.sinceSeen.set(chosen.id, 0);
      out.push({ def: chosen, risk, targetDC: target });
    }
  }

  // Fallback: Erholungskarten
  const ids = new Set(out.map(o=>o.def.id));
  function ensureRest(){
    const rest = pool.find(a=>a.id==="breath_reset");
    if (rest && !ids.has(rest.id)) return { def: rest, risk: Risk.Safe, targetDC: 0 };
    const med = pool.find(a=>a.id==="mindfulness_5");
    if (med && !ids.has(med.id)) return { def: med, risk: Risk.Safe, targetDC: 0 };
    return null;
  }
  while (out.length < 3) {
    const extra = ensureRest(); if (!extra) break;
    out.push(extra); ids.add(extra.def.id);
  }
  return out;
}

function applyAction(state, option) {
  const def = option.def;

  // Sicherheitsnetz
  const last = state.history.slice(-20);
  const succRate = last.length ? (last.filter(x=>x).length / last.length) : 1.0;
  const safety = (succRate < 0.40) ? 1 : 0;

  const baseStat = state.stats[def.stat];
  const statBonus = perkStatBonus(state.perks, def);
  const ls = luckShift(state.stats.Luck, state.perks);
  const roll = d10(state.rng);
  const total = baseStat + statBonus + roll + ls;
  const dcEff = Math.max(0, def.baseDC - safety);
  const success = total >= dcEff;

  // Wirtschaft mit Perks (Stress/Hoffnung/XP)
  const [stressAdj, hopeAdj, xpAdj] = applyPerkEconomy(state.perks, def, def.stressDelta, def.moneyDelta, def.xpGain);

  // Ressourcen
  state.energy = clamp(state.energy - def.energyCost, 0, 100); // negative energyCost gibt Energie zurück
  state.stress = clamp(state.stress + stressAdj, 0, 100);
  state.money += hopeAdj; // „Hoffnung“
  state.xp += xpAdj;

  // Cooldowns
  if (def.cooldown && def.cooldown > 0) state.cooldowns.set(def.id, def.cooldown);
  for (const [k,v] of [...state.cooldowns.entries()]) state.cooldowns.set(k, Math.max(0, v - 1));

  // Tags zählen nur bei Erfolg
  def.tags.forEach(tag=>{
    const cur = state.successTags.get(tag) ?? 0;
    state.successTags.set(tag, cur + (success ? 1 : 0));
  });

  if (success) def.onSuccess(state); else def.onFailure(state);

  // Endbedingungen
  if (state.stress >= 100) {
    endGame(state, "Rückfall/Überlastung", "Stress bei 100. Hinweis: Mehr Erholung und klare Grenzen einplanen.");
  } else {
    checkMilestones(state);
  }

  state.history.push(success);
  if (state.history.length > 50) state.history.shift();

  const prob = successProbability(state, def, def.baseDC); // Anzeige ohne Safety
  const parts = [];
  parts.push(`Aktion: ${def.name} [${String(option.risk).toLowerCase()}]`);
  parts.push(`DC=${def.baseDC}, Stat=${def.stat}, Erfolgs-%≈${prob}%`);
  let msg = `W10=${roll}, Luck-Shift +${ls}, Stat ${def.stat} ${baseStat}`;
  if (statBonus) msg += ` (+Perk ${statBonus})`;
  if (safety === 1) msg += `, Sicherheitsnetz −1 DC`;
  msg += ` → Summe=${total} ${success ? "≥" : "<"} DC ${dcEff} → ${success ? "Erfolg" : "Misserfolg"}; `;
  msg += `Δ: Energie ${signStr(-def.energyCost)}, Stress ${signStr(stressAdj)}, Hoffnung ${signStr(hopeAdj)}, Einsicht +${xpAdj}.`;
  return `${parts.join(" · ")}. ${msg}`;
}

function checkMilestones(state) {
  const ms = makeMilestones().filter(m => m.path === state.path && !state.milestonesAchieved.has(m.id));
  for (const m of ms) {
    if (m.requirements(state)) {
      m.rewards(state);
      state.milestonesAchieved.add(m.id);
      if (m.isPinnacle) {
        endGame(state, `Pinnacle erreicht: ${m.name}`, legacySummary(state));
        break;
      }
    }
  }
}

function legacySummary(state) {
  let rankScore = 0;
  if (["new_pillars"].some(id => state.milestonesAchieved.has(id))) rankScore = 3000;
  else if (state.milestonesAchieved.size >= 2) rankScore = 2000;
  else if (state.milestonesAchieved.size >= 1) rankScore = 1000;

  const hope = Math.trunc(state.money);           // „Hoffnung“
  const milestones = state.milestonesAchieved.size * 100;
  const wellbeing = (100 - state.stress) * 5;
  const score = rankScore + hope + milestones + wellbeing;

  return `Legacy-Score: ${score}  (Rang=${rankScore}, Hoffnung=${hope}, Milestones=${milestones}, Wohlbefinden=${wellbeing}).`;
}
function endGame(state, title, summary) {
  state.ended = true; state.endTitle = title; state.endSummary = summary;
}

/* ---------- UI Binding ---------- */
const elStart = document.getElementById("start-screen");
const elGame  = document.getElementById("game-screen");
const elEnd   = document.getElementById("end-screen");

const elGender = document.getElementById("gender-label");
const elGenderToggle = document.getElementById("gender-toggle");
const elAgeVal = document.getElementById("age-val");
const elAgeMinus = document.getElementById("age-minus");
const elAgePlus = document.getElementById("age-plus");
const elPtsLeft = document.getElementById("pts-left");
const elSeedInput = document.getElementById("seed-input");
const elConfirm = document.getElementById("confirm-btn");

const elOptions = document.getElementById("options");
const elLog = document.getElementById("log");
const elStatus = document.getElementById("status");
const elCooldowns = document.getElementById("cooldowns");

const elRefresh = document.getElementById("btn-refresh");
const elExit = document.getElementById("btn-exit");
const elRestart = document.getElementById("btn-restart");
const elFocus = document.getElementById("btn-focus");

const elEndTitle = document.getElementById("end-title");
const elEndSummary = document.getElementById("end-summary");
const elToStart = document.getElementById("btn-to-start");

/* Start State (pre-game) */
const pre = {
  gender: "Divers",
  age: 18,
  stats: { Appearance:2, Physique:2, Intellect:2, Luck:2 },
  pointsLeft: 10
};

let GAME = null;
const ACTIONS = makeActions();

function updateStartUI() {
  elGender.textContent = pre.gender;
  elAgeVal.textContent = pre.age;
  elPtsLeft.textContent = pre.pointsLeft;
  document.getElementById("stat-Appearance").textContent = pre.stats.Appearance;
  document.getElementById("stat-Physique").textContent  = pre.stats.Physique;
  document.getElementById("stat-Intellect").textContent = pre.stats.Intellect;
  document.getElementById("stat-Luck").textContent      = pre.stats.Luck;
  elConfirm.disabled = pre.pointsLeft !== 0;
}

function toStart() {
  pre.gender = "Divers"; pre.age = 18; pre.pointsLeft = 10;
  pre.stats = { Appearance:2, Physique:2, Intellect:2, Luck:2 };
  elSeedInput.value = "";
  updateStartUI();
  elStart.classList.remove("hidden");
  elGame.classList.add("hidden");
  elEnd.classList.add("hidden");
  elLog.innerHTML = "";
  document.body.classList.remove('focus');
  elFocus.textContent = "Fokusmodus: AUS";
}

function startGame() {
  const seed = (elSeedInput.value || (""+Date.now())).trim();
  GAME = createState(
    { gender: pre.gender, age: pre.age, background: "Neutral" },
    { ...pre.stats },
    new Set(),                          // keine Start-Perks
    Path.Ausbildung,                    // technisch notwendig; Label unten ersetzt
    seed
  );
  elStart.classList.add("hidden");
  elGame.classList.remove("hidden");
  refreshOptions();
  renderStatus();
  renderCooldowns();
}

function renderStatus() {
  const s = GAME;
  elStatus.innerHTML = `
    <div>Energie: <strong>${s.energy}</strong> &nbsp; Stress: <strong>${s.stress}</strong> &nbsp; Hoffnung: <strong>${s.money}</strong> &nbsp; Einsicht (XP): <strong>${s.xp}</strong></div>
    <div>Pfad: <span class="pill">Aufarbeitung</span></div>
    <div>Perks: ${s.perks.size ? [...s.perks].join(", ") : "–"}</div>
    <div>Meilensteine: ${s.milestonesAchieved.size ? [...s.milestonesAchieved].join(", ") : "–"}</div>
  `;
}
function renderCooldowns() {
  const lines = [];
  for (const [k,v] of GAME.cooldowns.entries()) {
    if (v > 0) lines.push(`• ${k}: ${v} Aktionen`);
  }
  elCooldowns.innerHTML = lines.length ? lines.join("<br>") : "Keine.";
}
function refreshOptions() {
  const opts = pickOptions(GAME, ACTIONS);
  elOptions.innerHTML = "";
  for (const opt of opts) elOptions.appendChild(optionCard(opt));
}

function optionCard(opt) {
  const def = opt.def;
  const prob = successProbability(GAME, def, def.baseDC);
  const div = document.createElement("div");
  div.className = "option-card";

  const [stressAdj] = applyPerkEconomy(GAME.perks, def, def.stressDelta, def.moneyDelta, def.xpGain);
  const canAfford = (GAME.energy - def.energyCost) >= 0 && (GAME.stress + Math.max(0, stressAdj)) <= 100;

  div.innerHTML = `
    <h4 style="margin:0 0 6px;">${def.name}<span class="badge">${String(opt.risk).toLowerCase()}</span></h4>
    <div class="meta">Stat: ${def.stat} · DC ${def.baseDC} · Erfolgs-%≈${prob}%</div>
    <div class="details" style="margin:6px 0 0;">
      <div class="muted">${def.desc}</div>
      <div class="meta">Kosten: Energie ${def.energyCost < 0 ? "+"+(-def.energyCost) : def.energyCost}
        · Stress ${signStr(def.stressDelta)} · Hoffnung ${signStr(def.moneyDelta)} · Einsicht +${def.xpGain}</div>
      <div class="meta">Tags: ${def.tags.join(", ") || "–"}</div>
    </div>
    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
      <button class="primary" ${canAfford ? "" : "disabled"}>Ausführen</button>
      <button class="toggle" type="button">Details ${document.body.classList.contains('focus') ? 'zeigen' : 'verbergen'}</button>
      ${canAfford ? "" : `<span class="danger">Nicht durchführbar (Energie/Stress)</span>`}
    </div>
  `;
  const btnRun = div.querySelector("button.primary");
  btnRun.addEventListener("click", ()=>{
    const entry = applyAction(GAME, opt);
    prependLog(entry);
    if (GAME.ended) { showEnd(); } else { refreshOptions(); renderStatus(); renderCooldowns(); }
  });
  const btnTog = div.querySelector("button.toggle");
  const details = div.querySelector(".details");
  btnTog.addEventListener("click", ()=>{
    const vis = details.style.display !== 'none';
    details.style.display = vis ? 'none' : 'block';
    btnTog.textContent = `Details ${vis ? 'zeigen' : 'verbergen'}`;
  });
  if (document.body.classList.contains('focus')) details.style.display = 'none';
  return div;
}
function prependLog(line) {
  const p = document.createElement("div");
  p.textContent = "• " + line;
  elLog.prepend(p);
}
function showEnd() {
  elGame.classList.add("hidden");
  elEnd.classList.remove("hidden");
  elEndTitle.textContent = GAME.endTitle;
  elEndSummary.textContent = GAME.endSummary;
}

/* ---------- Events ---------- */
document.querySelectorAll('button[data-stat]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const stat = btn.getAttribute('data-stat');
    const delta = parseInt(btn.getAttribute('data-delta'), 10);
    const cur = pre.stats[stat];
    if (delta > 0 && pre.pointsLeft <= 0) return;
    const nv = clamp(cur + delta, 0, 10);
    if (nv !== cur) {
      pre.stats[stat] = nv;
      pre.pointsLeft += (delta > 0 ? -1 : +1);
      pre.pointsLeft = clamp(pre.pointsLeft, 0, 10);
      updateStartUI();
    }
  });
});
elGenderToggle.addEventListener('click', ()=>{
  pre.gender = pre.gender === "Männlich" ? "Weiblich" : (pre.gender === "Weiblich" ? "Divers" : "Männlich");
  updateStartUI();
});
elAgeMinus.addEventListener('click', ()=>{ pre.age = Math.max(10, pre.age - 1); updateStartUI(); });
elAgePlus.addEventListener('click', ()=>{ pre.age = Math.min(80, pre.age + 1); updateStartUI(); });

elConfirm.addEventListener('click', startGame);
elRefresh.addEventListener('click', ()=>{ refreshOptions(); });
elExit.addEventListener('click', ()=>{
  endGame(GAME, "Freiwilliger Abschluss", legacySummary(GAME));
  showEnd();
});
elRestart.addEventListener('click', ()=>{ toStart(); });

elFocus.addEventListener('click', ()=>{
  document.body.classList.toggle('focus');
  const on = document.body.classList.contains('focus');
  elFocus.textContent = `Fokusmodus: ${on ? 'AN' : 'AUS'}`;
});

/* init */
toStart();
</script>
</body>
</html>
